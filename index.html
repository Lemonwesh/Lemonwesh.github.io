<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lemons Proxy | Educational Resource Portal</title>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --blueprint-bg: #0066CC;
            --blueprint-grid: rgba(255, 255, 255, 0.15);
            --blueprint-line: rgba(255, 255, 255, 0.8);
            --accent: #FF6B35;
            --warning: #FFD700;
            --paper: #F0F0F0;
        }

        body {
            background-color: var(--blueprint-bg);
            background-image: 
                linear-gradient(var(--blueprint-grid) 1px, transparent 1px),
                linear-gradient(90deg, var(--blueprint-grid) 1px, transparent 1px);
            background-size: 20px 20px;
            font-family: 'Courier Prime', monospace;
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Technical Border Decorations */
        .tech-border {
            position: fixed;
            border: 2px solid var(--blueprint-line);
            pointer-events: none;
            z-index: 1000;
        }

        .tech-border.top-left { top: 10px; left: 10px; width: 100px; height: 100px; border-right: none; border-bottom: none; }
        .tech-border.top-right { top: 10px; right: 10px; width: 100px; height: 100px; border-left: none; border-bottom: none; }
        .tech-border.bottom-left { bottom: 10px; left: 10px; width: 100px; height: 100px; border-right: none; border-top: none; }
        .tech-border.bottom-right { bottom: 10px; right: 10px; width: 100px; height: 100px; border-left: none; border-top: none; }

        header {
            text-align: center;
            padding: 40px 20px;
            border-bottom: 3px double var(--blueprint-line);
            position: relative;
            background: rgba(0, 0, 0, 0.2);
        }

        .blueprint-title {
            font-family: 'Share Tech Mono', monospace;
            font-size: 3rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            position: relative;
            display: inline-block;
        }

        .blueprint-title::before, .blueprint-title::after {
            content: '‚óÜ';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent);
        }

        .blueprint-title::before { left: -40px; }
        .blueprint-title::after { right: -40px; }

        .subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 10px;
            letter-spacing: 3px;
        }

        .drawing-number {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 0.8rem;
            border: 1px solid var(--blueprint-line);
            padding: 5px 10px;
            transform: rotate(-2deg);
        }

        nav {
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--blueprint-line);
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        nav button {
            background: transparent;
            border: 2px solid var(--blueprint-line);
            color: white;
            padding: 10px 25px;
            font-family: 'Share Tech Mono', monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        nav button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        nav button.active {
            background: var(--blueprint-line);
            color: var(--blueprint-bg);
            font-weight: bold;
        }

        .container {
            max-width: 1200px;
            margin: 40px auto;
            padding: 0 20px;
        }

        .section { display: none; animation: fadeIn 0.5s; }
        .section.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Proxy Section */
        .proxy-container {
            border: 3px solid var(--blueprint-line);
            background: rgba(0, 0, 0, 0.2);
            padding: 30px;
            position: relative;
        }

        .proxy-container::before {
            content: 'PROXY MODULE v2.0';
            position: absolute;
            top: -12px;
            left: 30px;
            background: var(--blueprint-bg);
            padding: 0 15px;
            font-size: 0.9rem;
            letter-spacing: 2px;
        }

        .proxy-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .proxy-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--blueprint-line);
            color: white;
            padding: 15px;
            font-family: 'Courier Prime', monospace;
            font-size: 1rem;
            outline: none;
        }

        .proxy-input::placeholder { color: rgba(255, 255, 255, 0.5); }

        .proxy-btn {
            background: var(--accent);
            border: 2px solid var(--accent);
            color: white;
            padding: 15px 30px;
            font-family: 'Share Tech Mono', monospace;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .proxy-btn:hover { background: transparent; color: var(--accent); }

        .iframe-container {
            width: 100%;
            height: 600px;
            border: 2px solid var(--blueprint-line);
            background: white;
            position: relative;
            display: none;
        }

        .iframe-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .proxy-options {
            margin: 15px 0;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .proxy-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        /* Games Grid */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 30px;
        }

        .game-card {
            border: 2px solid var(--blueprint-line);
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            text-align: center;
            position: relative;
            transition: transform 0.3s;
            cursor: pointer;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            background: rgba(0, 0, 0, 0.4);
        }

        .game-icon { font-size: 3rem; margin-bottom: 15px; }
        
        .game-title {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.2rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .game-desc { font-size: 0.85rem; opacity: 0.8; margin-bottom: 15px; }

        .play-btn {
            display: inline-block;
            border: 2px solid var(--accent);
            color: var(--accent);
            padding: 8px 20px;
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .play-btn:hover { background: var(--accent); color: white; }

        /* Game Container */
        .game-container {
            border: 3px solid var(--blueprint-line);
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            margin-top: 20px;
            position: relative;
            display: none;
        }

        .game-container.active { display: block; }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--blueprint-line);
        }

        .back-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 8px 16px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--blueprint-line);
        }

        .game-controls {
            text-align: center;
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Tools Section */
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
        }

        .tool-box {
            border: 2px solid var(--blueprint-line);
            padding: 25px;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
        }

        .tool-box h3 {
            font-family: 'Share Tech Mono', monospace;
            margin-bottom: 15px;
            color: var(--warning);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Calculator */
        .calc-display {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--blueprint-line);
            padding: 15px;
            margin-bottom: 15px;
            text-align: right;
            font-size: 1.5rem;
            font-family: 'Share Tech Mono', monospace;
            min-height: 50px;
            word-wrap: break-word;
        }

        .calc-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .calc-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px;
            font-family: 'Courier Prime', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .calc-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.05); }
        .calc-btn.operator { background: var(--accent); border-color: var(--accent); }

        /* Responsive */
        @media (max-width: 768px) {
            .blueprint-title { font-size: 2rem; }
            .blueprint-title::before, .blueprint-title::after { display: none; }
            .proxy-input-group { flex-direction: column; }
            .iframe-container { height: 400px; }
            canvas { max-width: 100%; }
        }

        .loader {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loader.active { display: block; }

        .blueprint-loader {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        footer {
            text-align: center;
            padding: 30px;
            border-top: 3px double var(--blueprint-line);
            margin-top: 50px;
            font-size: 0.8rem;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="tech-border top-left"></div>
    <div class="tech-border top-right"></div>
    <div class="tech-border bottom-left"></div>
    <div class="tech-border bottom-right"></div>

    <header>
        <div class="drawing-number">DWG: LEMONS-PROXY-v2.0</div>
        <h1 class="blueprint-title">Lemons Proxy</h1>
        <p class="subtitle">Secure Educational Resource Portal</p>
    </header>

    <nav>
        <button class="nav-btn active" onclick="showSection('proxy')">Proxy Browser</button>
        <button class="nav-btn" onclick="showSection('games')">Arcade</button>
        <button class="nav-btn" onclick="showSection('tools')">Utilities</button>
    </nav>

    <div class="container">
        <!-- Proxy Section -->
        <section id="proxy" class="section active">
            <div class="proxy-container">
                <div class="proxy-input-group">
                    <input type="text" class="proxy-input" id="urlInput" placeholder="Enter URL (e.g., https://example.com)" onkeypress="if(event.key==='Enter')loadProxy()">
                    <button class="proxy-btn" onclick="loadProxy()">Browse</button>
                </div>
                
                <div class="proxy-options">
                    <label><input type="checkbox" id="stealthMode"> Stealth Mode</label>
                    <label><input type="checkbox" id="useCORS" checked> Use CORS Proxy</label>
                    <select id="proxySelect" class="proxy-input" style="width: auto; padding: 5px;">
                        <option value="https://api.allorigins.win/raw?url=">AllOrigins</option>
                        <option value="https://corsproxy.io/?">CORSProxy.io</option>
                        <option value="https://api.codetabs.com/v1/proxy?quest=">CodeTabs</option>
                    </select>
                </div>

                <div class="loader" id="loader">
                    <div class="blueprint-loader"></div>
                    <p>Establishing secure connection...</p>
                </div>

                <div class="iframe-container" id="frameContainer">
                    <iframe id="proxyFrame" sandbox="allow-scripts allow-same-origin allow-forms allow-popups" referrerpolicy="no-referrer"></iframe>
                </div>

                <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.3);">
                    <h3 style="font-family: 'Share Tech Mono', monospace; margin-bottom: 10px; color: var(--warning);">Connection Status</h3>
                    <p id="statusText" style="font-size: 0.9rem;">Ready to connect. Some sites may be restricted by X-Frame-Options.</p>
                </div>
            </div>
        </section>

        <!-- Games Section -->
        <section id="games" class="section">
            <div id="gamesMenu">
                <div style="text-align: center; margin-bottom: 30px; padding: 20px; border: 2px dashed rgba(255,255,255,0.3);">
                    <h2 style="font-family: 'Share Tech Mono', monospace; letter-spacing: 3px;">ARCADE MODULE</h2>
                    <p style="margin-top: 10px; opacity: 0.8;">Select a game to launch</p>
                </div>

                <div class="games-grid">
                    <div class="game-card" onclick="launchGame('snake')">
                        <div class="game-icon">üêç</div>
                        <div class="game-title">Snake</div>
                        <div class="game-desc">Classic arcade snake game. Eat food, grow longer, avoid walls.</div>
                        <span class="play-btn">Play</span>
                    </div>

                    <div class="game-card" onclick="launchGame('pong')">
                        <div class="game-icon">üèì</div>
                        <div class="game-title">Pong</div>
                        <div class="game-desc">Original table tennis game. Player vs AI.</div>
                        <span class="play-btn">Play</span>
                    </div>

                    <div class="game-card" onclick="launchGame('tetris')">
                        <div class="game-icon">üß±</div>
                        <div class="game-title">Tetris</div>
                        <div class="game-desc">Block stacking puzzle game. Complete lines to score.</div>
                        <span class="play-btn">Play</span>
                    </div>

                    <div class="game-card" onclick="launchGame('minesweeper')">
                        <div class="game-icon">üí£</div>
                        <div class="game-title">Minesweeper</div>
                        <div class="game-desc">Clear the field without detonating mines.</div>
                        <span class="play-btn">Play</span>
                    </div>

                    <div class="game-card" onclick="launchGame('flappy')">
                        <div class="game-icon">üê¶</div>
                        <div class="game-title">Flappy Bird</div>
                        <div class="game-desc">Navigate through pipes. Tap to fly.</div>
                        <span class="play-btn">Play</span>
                    </div>

                    <div class="game-card" onclick="launchGame('2048')">
                        <div class="game-icon">üî¢</div>
                        <div class="game-title">2048</div>
                        <div class="game-desc">Slide tiles to combine numbers. Reach 2048.</div>
                        <span class="play-btn">Play</span>
                    </div>
                </div>
            </div>

            <!-- Game Containers -->
            <div id="gameContainer" class="game-container">
                <div class="game-header">
                    <h2 id="currentGameTitle" style="font-family: 'Share Tech Mono', monospace;">Game Title</h2>
                    <button class="back-btn" onclick="closeGame()">Exit Game</button>
                </div>
                <div id="gameCanvasContainer"></div>
                <div class="game-controls" id="gameControls"></div>
            </div>
        </section>

        <!-- Tools Section -->
        <section id="tools" class="section">
            <div class="tools-grid">
                <div class="tool-box">
                    <h3>Calculator</h3>
                    <div class="calc-display" id="calcDisplay">0</div>
                    <div class="calc-buttons">
                        <button class="calc-btn" onclick="calcClear()">C</button>
                        <button class="calc-btn" onclick="calcAppend('(')">(</button>
                        <button class="calc-btn" onclick="calcAppend(')')">)</button>
                        <button class="calc-btn operator" onclick="calcOp('/')">/</button>
                        
                        <button class="calc-btn" onclick="calcAppend('7')">7</button>
                        <button class="calc-btn" onclick="calcAppend('8')">8</button>
                        <button class="calc-btn" onclick="calcAppend('9')">9</button>
                        <button class="calc-btn operator" onclick="calcOp('*')">√ó</button>
                        
                        <button class="calc-btn" onclick="calcAppend('4')">4</button>
                        <button class="calc-btn" onclick="calcAppend('5')">5</button>
                        <button class="calc-btn" onclick="calcAppend('6')">6</button>
                        <button class="calc-btn operator" onclick="calcOp('-')">-</button>
                        
                        <button class="calc-btn" onclick="calcAppend('1')">1</button>
                        <button class="calc-btn" onclick="calcAppend('2')">2</button>
                        <button class="calc-btn" onclick="calcAppend('3')">3</button>
                        <button class="calc-btn operator" onclick="calcOp('+')">+</button>
                        
                        <button class="calc-btn" onclick="calcAppend('0')">0</button>
                        <button class="calc-btn" onclick="calcAppend('.')">.</button>
                        <button class="calc-btn" onclick="calcBack()">‚Üê</button>
                        <button class="calc-btn operator" onclick="calcEquals()">=</button>
                    </div>
                </div>

                <div class="tool-box">
                    <h3>Base64 Encoder</h3>
                    <textarea class="proxy-input" id="base64Input" rows="4" style="width: 100%; resize: vertical;" placeholder="Enter text to encode/decode"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="proxy-btn" onclick="encodeBase64()" style="flex: 1;">Encode</button>
                        <button class="proxy-btn" onclick="decodeBase64()" style="flex: 1;">Decode</button>
                    </div>
                    <div id="base64Output" style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid var(--blueprint-line); word-break: break-all;"></div>
                </div>

                <div class="tool-box">
                    <h3>Quick Links</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button class="calc-btn" style="text-align: left;" onclick="quickLink('https://www.google.com')">Google</button>
                        <button class="calc-btn" style="text-align: left;" onclick="quickLink('https://www.wikipedia.org')">Wikipedia</button>
                        <button class="calc-btn" style="text-align: left;" onclick="quickLink('https://www.desmos.com/calculator')">Desmos Calculator</button>
                        <button class="calc-btn" style="text-align: left;" onclick="quickLink('https://www.chess.com')">Chess.com</button>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <footer>
        <p>Lemons Proxy v2.0 | Educational Use Only</p>
        <p style="margin-top: 10px; font-size: 0.7rem;">Built with 90s Blueprint Aesthetic</p>
    </footer>

    <script>
        // Navigation
        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            
            document.getElementById(sectionId).classList.add('active');
            event.target.classList.add('active');
            
            // Stop any running games when switching sections
            if (sectionId !== 'games') {
                closeGame();
            }
        }

        // Proxy Functionality
        function loadProxy() {
            const url = document.getElementById('urlInput').value;
            const useCORS = document.getElementById('useCORS').checked;
            const proxyUrl = document.getElementById('proxySelect').value;
            const stealth = document.getElementById('stealthMode').checked;
            const loader = document.getElementById('loader');
            const container = document.getElementById('frameContainer');
            const frame = document.getElementById('proxyFrame');
            const status = document.getElementById('statusText');
            
            if (!url) {
                alert('Please enter a URL');
                return;
            }

            loader.classList.add('active');
            container.style.display = 'none';
            status.textContent = 'Connecting...';

            setTimeout(() => {
                loader.classList.remove('active');
                container.style.display = 'block';
                
                let targetUrl = url;
                if (!url.startsWith('http')) {
                    targetUrl = 'https://' + url;
                }
                
                if (useCORS) {
                    frame.src = proxyUrl + encodeURIComponent(targetUrl);
                    status.textContent = 'Connected via CORS proxy. Some sites may not display correctly.';
                } else {
                    frame.src = targetUrl;
                    status.textContent = 'Direct connection. If site does not load, it may have X-Frame-Options protection enabled.';
                }
                
                if (stealth) {
                    document.title = 'Google Docs';
                } else {
                    document.title = 'Lemons Proxy | Educational Resource Portal';
                }
            }, 1000);
        }

        // Games System
        let currentGame = null;
        let gameInterval = null;

        function launchGame(gameType) {
            const container = document.getElementById('gameContainer');
            const menu = document.getElementById('gamesMenu');
            const canvasContainer = document.getElementById('gameCanvasContainer');
            const title = document.getElementById('currentGameTitle');
            const controls = document.getElementById('gameControls');
            
            menu.style.display = 'none';
            container.classList.add('active');
            
            // Clear previous game
            canvasContainer.innerHTML = '';
            if (gameInterval) clearInterval(gameInterval);
            
            switch(gameType) {
                case 'snake':
                    title.textContent = 'SNAKE';
                    controls.textContent = 'Use Arrow Keys to Move | Pause: P';
                    initSnake(canvasContainer);
                    break;
                case 'pong':
                    title.textContent = 'PONG';
                    controls.textContent = 'Mouse to Control Paddle | First to 7 Wins';
                    initPong(canvasContainer);
                    break;
                case 'tetris':
                    title.textContent = 'TETRIS';
                    controls.textContent = 'Arrows: Move | Up: Rotate | Down: Soft Drop | Space: Hard Drop';
                    initTetris(canvasContainer);
                    break;
                case 'minesweeper':
                    title.textContent = 'MINESWEEPER';
                    controls.textContent = 'Left Click: Reveal | Right Click: Flag';
                    initMinesweeper(canvasContainer);
                    break;
                case 'flappy':
                    title.textContent = 'FLAPPY BIRD';
                    controls.textContent = 'Space/Click: Jump | Avoid Pipes';
                    initFlappy(canvasContainer);
                    break;
                case '2048':
                    title.textContent = '2048';
                    controls.textContent = 'Arrow Keys: Slide Tiles | Combine numbers to reach 2048';
                    init2048(canvasContainer);
                    break;
            }
        }

        function closeGame() {
            const container = document.getElementById('gameContainer');
            const menu = document.getElementById('gamesMenu');
            
            container.classList.remove('active');
            menu.style.display = 'block';
            
            if (gameInterval) clearInterval(gameInterval);
            document.getElementById('gameCanvasContainer').innerHTML = '';
            currentGame = null;
        }

        // SNAKE GAME
        function initSnake(container) {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 400;
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const grid = 20;
            let count = 0;
            let score = 0;
            
            const snake = {
                x: 160,
                y: 160,
                dx: grid,
                dy: 0,
                cells: [],
                maxCells: 4
            };
            
            const apple = {
                x: 320,
                y: 320
            };
            
            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min)) + min;
            }
            
            function loop() {
                gameInterval = requestAnimationFrame(loop);
                
                if (++count < 4) return;
                
                count = 0;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                snake.x += snake.dx;
                snake.y += snake.dy;
                
                if (snake.x < 0 || snake.x >= canvas.width || snake.y < 0 || snake.y >= canvas.height) {
                    reset();
                    return;
                }
                
                snake.cells.unshift({x: snake.x, y: snake.y});
                
                if (snake.cells.length > snake.maxCells) {
                    snake.cells.pop();
                }
                
                ctx.fillStyle = 'red';
                ctx.fillRect(apple.x, apple.y, grid-1, grid-1);
                
                ctx.fillStyle = 'green';
                snake.cells.forEach(function(cell, index) {
                    ctx.fillRect(cell.x, cell.y, grid-1, grid-1);
                    
                    if (cell.x === apple.x && cell.y === apple.y) {
                        snake.maxCells++;
                        score++;
                        apple.x = getRandomInt(0, 20) * grid;
                        apple.y = getRandomInt(0, 20) * grid;
                    }
                    
                    for (let i = index + 1; i < snake.cells.length; i++) {
                        if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {
                            reset();
                        }
                    }
                });
                
                ctx.fillStyle = 'white';
                ctx.font = '20px monospace';
                ctx.fillText('Score: ' + score, 10, 30);
            }
            
            function reset() {
                snake.x = 160;
                snake.y = 160;
                snake.cells = [];
                snake.maxCells = 4;
                snake.dx = grid;
                snake.dy = 0;
                apple.x = getRandomInt(0, 20) * grid;
                apple.y = getRandomInt(0, 20) * grid;
                score = 0;
            }
            
            document.addEventListener('keydown', function(e) {
                if (e.which === 37 && snake.dx === 0) {
                    snake.dx = -grid;
                    snake.dy = 0;
                } else if (e.which === 38 && snake.dy === 0) {
                    snake.dy = -grid;
                    snake.dx = 0;
                } else if (e.which === 39 && snake.dx === 0) {
                    snake.dx = grid;
                    snake.dy = 0;
                } else if (e.which === 40 && snake.dy === 0) {
                    snake.dy = grid;
                    snake.dx = 0;
                }
            });
            
            loop();
        }

        // PONG GAME
        function initPong(container) {
            const canvas = document.createElement('canvas');
            canvas.width = 750;
            canvas.height = 585;
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const grid = 15;
            const paddleHeight = grid * 5;
            const maxPaddleY = canvas.height - grid - paddleHeight;
            
            let paddleSpeed = 6;
            let ballSpeed = 5;
            let playerScore = 0;
            let aiScore = 0;
            
            const leftPaddle = {
                x: grid * 2,
                y: canvas.height / 2 - paddleHeight / 2,
                width: grid,
                height: paddleHeight,
                dy: 0
            };
            
            const rightPaddle = {
                x: canvas.width - grid * 3,
                y: canvas.height / 2 - paddleHeight / 2,
                width: grid,
                height: paddleHeight,
                dy: 0
            };
            
            const ball = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: grid,
                height: grid,
                resetting: false,
                dx: ballSpeed,
                dy: -ballSpeed
            };
            
            function collides(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            function loop() {
                gameInterval = requestAnimationFrame(loop);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                leftPaddle.y += leftPaddle.dy;
                rightPaddle.y += rightPaddle.dy;
                
                if (leftPaddle.y < grid) leftPaddle.y = grid;
                if (leftPaddle.y > maxPaddleY) leftPaddle.y = maxPaddleY;
                
                // AI Movement
                if (rightPaddle.y + rightPaddle.height / 2 < ball.y) {
                    rightPaddle.dy = paddleSpeed * 0.8;
                } else {
                    rightPaddle.dy = -paddleSpeed * 0.8;
                }
                
                if (rightPaddle.y < grid) rightPaddle.y = grid;
                if (rightPaddle.y > maxPaddleY) rightPaddle.y = maxPaddleY;
                
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                if (ball.y < grid) {
                    ball.y = grid;
                    ball.dy *= -1;
                } else if (ball.y + grid > canvas.height - grid) {
                    ball.y = canvas.height - grid * 2;
                    ball.dy *= -1;
                }
                
                if ((ball.x < 0 || ball.x > canvas.width) && !ball.resetting) {
                    if (ball.x < 0) aiScore++;
                    else playerScore++;
                    
                    ball.resetting = true;
                    setTimeout(() => {
                        ball.resetting = false;
                        ball.x = canvas.width / 2;
                        ball.y = canvas.height / 2;
                        ball.dx = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
                        ball.dy = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
                    }, 1000);
                }
                
                if (collides(ball, leftPaddle)) {
                    ball.dx *= -1;
                    ball.x = leftPaddle.x + leftPaddle.width;
                } else if (collides(ball, rightPaddle)) {
                    ball.dx *= -1;
                    ball.x = rightPaddle.x - ball.width;
                }
                
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, grid);
                ctx.fillRect(0, canvas.height - grid, canvas.width, canvas.height);
                
                for (let i = grid; i < canvas.height - grid; i += grid * 2) {
                    ctx.fillRect(canvas.width / 2 - grid / 2, i, grid, grid);
                }
                
                ctx.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
                ctx.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);
                ctx.fillRect(ball.x, ball.y, ball.width, ball.height);
                
                ctx.font = '30px monospace';
                ctx.fillText(playerScore, canvas.width / 4, 50);
                ctx.fillText(aiScore, 3 * canvas.width / 4, 50);
            }
            
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                leftPaddle.y = e.clientY - rect.top - leftPaddle.height / 2;
            });
            
            loop();
        }

        // TETRIS GAME
        function initTetris(container) {
            const canvas = document.createElement('canvas');
            canvas.width = 240;
            canvas.height = 400;
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const scale = 20;
            
            ctx.scale(scale, scale);
            
            const arena = createMatrix(12, 20);
            
            const player = {
                pos: {x: 0, y: 0},
                matrix: null,
                score: 0
            };
            
            const pieces = 'ILJOTSZ';
            
            function createMatrix(w, h) {
                const matrix = [];
                while (h--) {
                    matrix.push(new Array(w).fill(0));
                }
                return matrix;
            }
            
            function createPiece(type) {
                if (type === 'I') {
                    return [
                        [0, 1, 0, 0],
                        [0, 1, 0, 0],
                        [0, 1, 0, 0],
                        [0, 1, 0, 0],
                    ];
                } else if (type === 'L') {
                    return [
                        [0, 2, 0],
                        [0, 2, 0],
                        [0, 2, 2],
                    ];
                } else if (type === 'J') {
                    return [
                        [0, 3, 0],
                        [0, 3, 0],
                        [3, 3, 0],
                    ];
                } else if (type === 'O') {
                    return [
                        [4, 4],
                        [4, 4],
                    ];
                } else if (type === 'Z') {
                    return [
                        [5, 5, 0],
                        [0, 5, 5],
                        [0, 0, 0],
                    ];
                } else if (type === 'S') {
                    return [
                        [0, 6, 6],
                        [6, 6, 0],
                        [0, 0, 0],
                    ];
                } else if (type === 'T') {
                    return [
                        [0, 7, 0],
                        [7, 7, 7],
                        [0, 0, 0],
                    ];
                }
            }
            
            function drawMatrix(matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            ctx.fillStyle = ['', 'cyan', 'blue', 'orange', 'yellow', 'green', 'red', 'purple'][value];
                            ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        }
                    });
                });
            }
            
            function draw() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                drawMatrix(arena, {x: 0, y: 0});
                drawMatrix(player.matrix, player.pos);
                
                ctx.fillStyle = 'white';
                ctx.font = '0.5px monospace';
                ctx.fillText('Score: ' + player.score, 0.2, 0.5);
            }
            
            function merge(arena, player) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            arena[y + player.pos.y][x + player.pos.x] = value;
                        }
                    });
                });
            }
            
            function rotate(matrix) {
                const x = matrix.map((val, index) => matrix.map(row => row[index]).reverse());
                return x;
            }
            
            function playerRotate() {
                const pos = player.pos.x;
                let offset = 1;
                player.matrix = rotate(player.matrix);
                while (collide(arena, player)) {
                    player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > player.matrix[0].length) {
                        player.matrix = rotate(player.matrix);
                        player.pos.x = pos;
                        return;
                    }
                }
            }
            
            function collide(arena, player) {
                const m = player.matrix;
                const o = player.pos;
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 &&
                           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            function playerReset() {
                player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
                player.pos.y = 0;
                player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
                
                if (collide(arena, player)) {
                    arena.forEach(row => row.fill(0));
                    player.score = 0;
                }
            }
            
            function arenaSweep() {
                let rowCount = 1;
                outer: for (let y = arena.length -1; y > 0; --y) {
                    for (let x = 0; x < arena[y].length; ++x) {
                        if (arena[y][x] === 0) {
                            continue outer;
                        }
                    }
                    
                    const row = arena.splice(y, 1)[0].fill(0);
                    arena.unshift(row);
                    ++y;
                    
                    player.score += rowCount * 10;
                    rowCount *= 2;
                }
            }
            
            function playerDrop() {
                player.pos.y++;
                if (collide(arena, player)) {
                    player.pos.y--;
                    merge(arena, player);
                    playerReset();
                    arenaSweep();
                }
                dropCounter = 0;
            }
            
            let dropCounter = 0;
            let dropInterval = 1000;
            let lastTime = 0;
            
            function update(time = 0) {
                const deltaTime = time - lastTime;
                lastTime = time;
                
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) {
                    playerDrop();
                }
                
                draw();
                gameInterval = requestAnimationFrame(update);
            }
            
            document.addEventListener('keydown', event => {
                if (event.keyCode === 37) {
                    player.pos.x--;
                    if (collide(arena, player)) {
                        player.pos.x++;
                    }
                } else if (event.keyCode === 39) {
                    player.pos.x++;
                    if (collide(arena, player)) {
                        player.pos.x--;
                    }
                } else if (event.keyCode === 40) {
                    playerDrop();
                } else if (event.keyCode === 38) {
                    playerRotate();
                } else if (event.keyCode === 32) {
                    while (!collide(arena, player)) {
                        player.pos.y++;
                    }
                    player.pos.y--;
                    playerDrop();
                }
            });
            
            playerReset();
            update();
        }

        // MINESWEEPER
        function initMinesweeper(container) {
            const width = 10;
            const height = 10;
            const bombCount = 20;
            
            const grid = document.createElement('div');
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(10, 30px)';
            grid.style.gap = '2px';
            grid.style.margin = '0 auto';
            grid.style.width = 'fit-content';
            
            const squares = [];
            let isGameOver = false;
            let flags = 0;
            
            // Create Board
            const bombsArray = Array(bombCount).fill('bomb');
            const emptyArray = Array(width * height - bombCount).fill('valid');
            const gameArray = emptyArray.concat(bombsArray);
            const shuffledArray = gameArray.sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < width * height; i++) {
                const square = document.createElement('div');
                square.setAttribute('id', i);
                square.className = shuffledArray[i];
                square.style.width = '30px';
                square.style.height = '30px';
                square.style.background = '#aaa';
                square.style.border = '2px solid white';
                square.style.display = 'flex';
                square.style.alignItems = 'center';
                square.style.justifyContent = 'center';
                square.style.cursor = 'pointer';
                square.style.fontSize = '14px';
                square.style.fontWeight = 'bold';
                
                grid.appendChild(square);
                squares.push(square);
                
                square.addEventListener('click', function(e) {
                    click(square);
                });
                
                square.oncontextmenu = function(e) {
                    e.preventDefault();
                    addFlag(square);
                }
            }
            
            // Add numbers
            for (let i = 0; i < squares.length; i++) {
                let total = 0;
                const isLeftEdge = (i % width === 0);
                const isRightEdge = (i % width === width - 1);
                
                if (squares[i].classList.contains('valid')) {
                    if (i > 0 && !isLeftEdge && squares[i - 1].classList.contains('bomb')) total++;
                    if (i > 9 && !isRightEdge && squares[i + 1 - width].classList.contains('bomb')) total++;
                    if (i > 10 && squares[i - width].classList.contains('bomb')) total++;
                    if (i > 11 && !isLeftEdge && squares[i - 1 - width].classList.contains('bomb')) total++;
                    if (i < 98 && !isRightEdge && squares[i + 1].classList.contains('bomb')) total++;
                    if (i < 90 && !isLeftEdge && squares[i - 1 + width].classList.contains('bomb')) total++;
                    if (i < 88 && !isRightEdge && squares[i + 1 + width].classList.contains('bomb')) total++;
                    if (i < 89 && squares[i + width].classList.contains('bomb')) total++;
                    squares[i].setAttribute('data', total);
                }
            }
            
            function addFlag(square) {
                if (isGameOver) return;
                if (!square.classList.contains('checked') && (flags < bombCount)) {
                    if (!square.classList.contains('flag')) {
                        square.classList.add('flag');
                        square.textContent = 'üö©';
                        flags++;
                    } else {
                        square.classList.remove('flag');
                        square.textContent = '';
                        flags--;
                    }
                }
            }
            
            function click(square) {
                if (isGameOver || square.classList.contains('checked') || square.classList.contains('flag')) return;
                
                if (square.classList.contains('bomb')) {
                    gameOver();
                } else {
                    let total = square.getAttribute('data');
                    if (total != 0) {
                        square.classList.add('checked');
                        square.textContent = total;
                        square.style.background = '#ddd';
                        if (total == 1) square.style.color = 'blue';
                        if (total == 2) square.style.color = 'green';
                        if (total == 3) square.style.color = 'red';
                        if (total == 4) square.style.color = 'navy';
                    } else {
                        checkSquare(square);
                    }
                }
            }
            
            function checkSquare(square) {
                const currentId = square.id;
                const isLeftEdge = (currentId % width === 0);
                const isRightEdge = (currentId % width === width - 1);
                
                setTimeout(() => {
                    if (currentId > 0 && !isLeftEdge) {
                        const newId = squares[parseInt(currentId) - 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if (currentId > 9 && !isRightEdge) {
                        const newId = squares[parseInt(currentId) + 1 - width].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if (currentId > 10) {
                        const newId = squares[parseInt(currentId) - width].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if (currentId > 11 && !isLeftEdge) {
                        const newId = squares[parseInt(currentId) - 1 - width].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if (currentId < 98 && !isRightEdge) {
                        const newId = squares[parseInt(currentId) + 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if (currentId < 90 && !isLeftEdge) {
                        const newId = squares[parseInt(currentId) - 1 + width].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if (currentId < 88 && !isRightEdge) {
                        const newId = squares[parseInt(currentId) + 1 + width].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if (currentId < 89) {
                        const newId = squares[parseInt(currentId) + width].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                }, 10);
            }
            
            function gameOver() {
                isGameOver = true;
                squares.forEach(square => {
                    if (square.classList.contains('bomb')) {
                        square.textContent = 'üí£';
                        square.style.background = 'red';
                    }
                });
                setTimeout(() => alert('Game Over!'), 10);
            }
            
            container.appendChild(grid);
        }

        // FLAPPY BIRD
        function initFlappy(container) {
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 480;
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            let birdY = 150;
            let birdVelocity = 0;
            let birdAcceleration = 0.2;
            let isGameOver = false;
            let score = 0;
            let pipes = [];
            let frames = 0;
            
            function drawBird() {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(50, birdY, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'orange';
                ctx.fillRect(55, birdY - 3, 6, 6);
            }
            
            function drawPipes() {
                ctx.fillStyle = 'green';
                pipes.forEach(pipe => {
                    ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
                    ctx.fillRect(pipe.x, canvas.height - pipe.bottom, pipe.width, pipe.bottom);
                });
            }
            
            function update() {
                if (isGameOver) return;
                
                ctx.fillStyle = 'skyblue';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                birdVelocity += birdAcceleration;
                birdY += birdVelocity;
                
                if (frames % 100 === 0) {
                    const pipeHeight = Math.random() * 200 + 50;
                    const gap = 120;
                    pipes.push({
                        x: canvas.width,
                        width: 40,
                        top: pipeHeight,
                        bottom: canvas.height - pipeHeight - gap,
                        passed: false
                    });
                }
                
                pipes.forEach((pipe, index) => {
                    pipe.x -= 2;
                    
                    if (!pipe.passed && pipe.x + pipe.width < 50) {
                        score++;
                        pipe.passed = true;
                    }
                    
                    if (pipe.x + pipe.width < 0) {
                        pipes.splice(index, 1);
                    }
                    
                    if (50 + 10 > pipe.x && 50 - 10 < pipe.x + pipe.width) {
                        if (birdY - 10 < pipe.top || birdY + 10 > canvas.height - pipe.bottom) {
                            isGameOver = true;
                            setTimeout(() => {
                                alert('Game Over! Score: ' + score);
                                reset();
                            }, 10);
                        }
                    }
                });
                
                if (birdY < 0 || birdY > canvas.height) {
                    isGameOver = true;
                    setTimeout(() => {
                        alert('Game Over! Score: ' + score);
                        reset();
                    }, 10);
                }
                
                drawPipes();
                drawBird();
                
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Score: ' + score, 10, 30);
                
                frames++;
                gameInterval = requestAnimationFrame(update);
            }
            
            function reset() {
                birdY = 150;
                birdVelocity = 0;
                isGameOver = false;
                score = 0;
                pipes = [];
                frames = 0;
                update();
            }
            
            function jump() {
                if (!isGameOver) {
                    birdVelocity = -5;
                }
            }
            
            canvas.addEventListener('click', jump);
            document.addEventListener('keydown', function(e) {
                if (e.code === 'Space') {
                    e.preventDefault();
                    jump();
                }
            });
            
            update();
        }

        // 2048 GAME
        function init2048(container) {
            const gridSize = 4;
            let grid = [];
            let score = 0;
            
            const gameDiv = document.createElement('div');
            gameDiv.style.width = '340px';
            gameDiv.style.margin = '0 auto';
            gameDiv.style.background = '#bbada0';
            gameDiv.style.padding = '10px';
            gameDiv.style.borderRadius = '6px';
            
            const scoreDiv = document.createElement('div');
            scoreDiv.style.textAlign = 'center';
            scoreDiv.style.marginBottom = '10px';
            scoreDiv.style.fontSize = '24px';
            scoreDiv.style.fontWeight = 'bold';
            scoreDiv.textContent = 'Score: 0';
            gameDiv.appendChild(scoreDiv);
            
            const gridDiv = document.createElement('div');
            gridDiv.style.display = 'grid';
            gridDiv.style.gridTemplateColumns = 'repeat(4, 75px)';
            gridDiv.style.gap = '10px';
            gridDiv.style.background = '#bbada0';
            
            function initGrid() {
                grid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
                addRandomTile();
                addRandomTile();
                updateDisplay();
            }
            
            function addRandomTile() {
                const available = [];
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (grid[r][c] === 0) available.push({r, c});
                    }
                }
                if (available.length > 0) {
                    const {r, c} = available[Math.floor(Math.random() * available.length)];
                    grid[r][c] = Math.random() < 0.9 ? 2 : 4;
                }
            }
            
            function updateDisplay() {
                gridDiv.innerHTML = '';
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cell = document.createElement('div');
                        cell.style.width = '75px';
                        cell.style.height = '75px';
                        cell.style.background = getColor(grid[r][c]);
                        cell.style.display = 'flex';
                        cell.style.alignItems = 'center';
                        cell.style.justifyContent = 'center';
                        cell.style.fontSize = '24px';
                        cell.style.fontWeight = 'bold';
                        cell.style.color = grid[r][c] > 4 ? 'white' : '#776e65';
                        cell.style.borderRadius = '3px';
                        cell.textContent = grid[r][c] || '';
                        gridDiv.appendChild(cell);
                    }
                }
                scoreDiv.textContent = 'Score: ' + score;
            }
            
            function getColor(value) {
                const colors = {
                    0: '#cdc1b4',
                    2: '#eee4da',
                    4: '#ede0c8',
                    8: '#f2b179',
                    16: '#f59563',
                    32: '#f67c5f',
                    64: '#f65e3b',
                    128: '#edcf72',
                    256: '#edcc61',
                    512: '#edc850',
                    1024: '#edc53f',
                    2048: '#edc22e'
                };
                return colors[value] || '#3c3a32';
            }
            
            function move(direction) {
                let moved = false;
                const newGrid = grid.map(row => [...row]);
                
                if (direction === 'left' || direction === 'right') {
                    for (let r = 0; r < gridSize; r++) {
                        let row = newGrid[r].filter(val => val);
                        if (direction === 'right') row.reverse();
                        
                        for (let i = 0; i < row.length - 1; i++) {
                            if (row[i] === row[i + 1]) {
                                row[i] *= 2;
                                score += row[i];
                                row.splice(i + 1, 1);
                                moved = true;
                            }
                        }
                        
                        while (row.length < gridSize) row.push(0);
                        if (direction === 'right') row.reverse();
                        
                        for (let c = 0; c < gridSize; c++) {
                            if (newGrid[r][c] !== row[c]) moved = true;
                            newGrid[r][c] = row[c];
                        }
                    }
                } else {
                    for (let c = 0; c < gridSize; c++) {
                        let col = [];
                        for (let r = 0; r < gridSize; r++) col.push(newGrid[r][c]);
                        col = col.filter(val => val);
                        
                        if (direction === 'down') col.reverse();
                        
                        for (let i = 0; i < col.length - 1; i++) {
                            if (col[i] === col[i + 1]) {
                                col[i] *= 2;
                                score += col[i];
                                col.splice(i + 1, 1);
                                moved = true;
                            }
                        }
                        
                        while (col.length < gridSize) col.push(0);
                        if (direction === 'down') col.reverse();
                        
                        for (let r = 0; r < gridSize; r++) {
                            if (newGrid[r][c] !== col[r]) moved = true;
                            newGrid[r][c] = col[r];
                        }
                    }
                }
                
                if (moved) {
                    grid = newGrid;
                    addRandomTile();
                    updateDisplay();
                    
                    if (isGameOver()) {
                        setTimeout(() => alert('Game Over! Final Score: ' + score), 100);
                    }
                }
            }
            
            function isGameOver() {
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (grid[r][c] === 0) return false;
                        if (c < gridSize - 1 && grid[r][c] === grid[r][c + 1]) return false;
                        if (r < gridSize - 1 && grid[r][c] === grid[r + 1][c]) return false;
                    }
                }
                return true;
            }
            
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowUp': move('up'); break;
                    case 'ArrowDown': move('down'); break;
                    case 'ArrowLeft': move('left'); break;
                    case 'ArrowRight': move('right'); break;
                }
            });
            
            gameDiv.appendChild(gridDiv);
            container.appendChild(gameDiv);
            initGrid();
        }

        // Calculator
        let calcExpression = '';
        let calcDisplay = document.getElementById('calcDisplay');

        function calcAppend(val) {
            if (calcDisplay.textContent === '0' && val !== '.') {
                calcExpression = val;
            } else {
                calcExpression += val;
            }
            calcDisplay.textContent = calcExpression;
        }

        function calcOp(op) {
            calcExpression += ' ' + op + ' ';
            calcDisplay.textContent = calcExpression;
        }

        function calcClear() {
            calcExpression = '';
            calcDisplay.textContent = '0';
        }

        function calcBack() {
            calcExpression = calcExpression.slice(0, -1);
            calcDisplay.textContent = calcExpression || '0';
        }

        function calcEquals() {
            try {
                calcExpression = eval(calcExpression).toString();
                calcDisplay.textContent = calcExpression;
            } catch {
                calcDisplay.textContent = 'Error';
                setTimeout(calcClear, 1500);
            }
        }

        // Base64 Tools
        function encodeBase64() {
            const input = document.getElementById('base64Input').value;
            document.getElementById('base64Output').textContent = btoa(input);
        }

        function decodeBase64() {
            const input = document.getElementById('base64Input').value;
            try {
                document.getElementById('base64Output').textContent = atob(input);
            } catch {
                document.getElementById('base64Output').textContent = 'Invalid Base64';
            }
        }

        function quickLink(url) {
            document.getElementById('urlInput').value = url;
            showSection('proxy');
            document.querySelector('.nav-btn').classList.remove('active');
            document.querySelectorAll('.nav-btn')[0].classList.add('active');
            loadProxy();
        }
    </script>
</body>
</html>
